{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Flask-mailing \u00b6 The flask-mailing simple lightweight mail system, sending emails and attachments(individual && bulk) fully asynchronously. Flask_Mail is dead now. To use the mail service with your project you can use eaither Flask-Mailing for legacy or Flask-Mailman for Django type implementation. A Basic Demo for better understanding \u00b6 from flask import Flask , jsonify from flask_mailing import Mail , Message mail = Mail () def create_app (): app = Flask ( __name__ ) app . config [ 'MAIL_USERNAME' ] = \"your-email@your-domain.com\" app . config [ 'MAIL_PASSWORD' ] = \"world_top_secret_password\" app . config [ 'MAIL_PORT' ] = 587 app . config [ 'MAIL_SERVER' ] = \"your-email-server.com\" app . config [ 'MAIL_USE_TLS' ] = True app . config [ 'MAIL_USE_SSL' ] = False app . config [ 'MAIL_DEFAULT_SENDER' ] = \"your-email@your-domain.com\" mail . init_app ( app ) return app #send a simple email using flask_mailing module. app = create_app () @app . get ( \"/email\" ) async def simple_send (): message = Message ( subject = \"Flask-Mailing module\" , recipients = [ \"aniketsarkar@yahoo.com\" ], body = \"This is the basic email body\" , ) await mail . send_message ( message ) return jsonify ( status_code = 200 , content = { \"message\" : \"email has been sent\" }) Using Jinja2 HTML Templates \u00b6 In order to use Jinja template langauge, your must specify email folder within your applications working directory. In sending HTML emails, the CSS expected by mail servers -outlook, google, etc- must be inline CSS. Flask mail passes \"body\" to the rendered template. In creating the template for emails the dynamic objects should be used with the assumption that the variable is named \" body \" and that it is a python dict. check out jinja2 for more details jinja2 Guide for Email Utils \u00b6 The utility allows you to check temporary email addresses, you can block any email or domain. You can connect Redis to save and check email addresses. If you do not provide a Redis configuration, then the utility will save it in the list or set by default. Writing unittests using Flask-Mailing \u00b6 Flask mails allows you to write unittest for your application without sending emails to non existent email address by mocking the email to be sent. To mock sending out mails, set the suppress configuraton to true. Suppress send defaults to False to prevent mocking within applications. Support for Reply-To header is added \u00b6 Use this just like bcc but to specify addresses that should receive a reply to your message. E-mail systems MAY respect this as per RFC 2822.","title":"Flask MAILING"},{"location":"#flask-mailing","text":"The flask-mailing simple lightweight mail system, sending emails and attachments(individual && bulk) fully asynchronously. Flask_Mail is dead now. To use the mail service with your project you can use eaither Flask-Mailing for legacy or Flask-Mailman for Django type implementation.","title":"Flask-mailing"},{"location":"#a-basic-demo-for-better-understanding","text":"from flask import Flask , jsonify from flask_mailing import Mail , Message mail = Mail () def create_app (): app = Flask ( __name__ ) app . config [ 'MAIL_USERNAME' ] = \"your-email@your-domain.com\" app . config [ 'MAIL_PASSWORD' ] = \"world_top_secret_password\" app . config [ 'MAIL_PORT' ] = 587 app . config [ 'MAIL_SERVER' ] = \"your-email-server.com\" app . config [ 'MAIL_USE_TLS' ] = True app . config [ 'MAIL_USE_SSL' ] = False app . config [ 'MAIL_DEFAULT_SENDER' ] = \"your-email@your-domain.com\" mail . init_app ( app ) return app #send a simple email using flask_mailing module. app = create_app () @app . get ( \"/email\" ) async def simple_send (): message = Message ( subject = \"Flask-Mailing module\" , recipients = [ \"aniketsarkar@yahoo.com\" ], body = \"This is the basic email body\" , ) await mail . send_message ( message ) return jsonify ( status_code = 200 , content = { \"message\" : \"email has been sent\" })","title":"A Basic Demo for better understanding"},{"location":"#using-jinja2-html-templates","text":"In order to use Jinja template langauge, your must specify email folder within your applications working directory. In sending HTML emails, the CSS expected by mail servers -outlook, google, etc- must be inline CSS. Flask mail passes \"body\" to the rendered template. In creating the template for emails the dynamic objects should be used with the assumption that the variable is named \" body \" and that it is a python dict. check out jinja2 for more details jinja2","title":"Using Jinja2 HTML Templates"},{"location":"#guide-for-email-utils","text":"The utility allows you to check temporary email addresses, you can block any email or domain. You can connect Redis to save and check email addresses. If you do not provide a Redis configuration, then the utility will save it in the list or set by default.","title":"Guide for Email Utils"},{"location":"#writing-unittests-using-flask-mailing","text":"Flask mails allows you to write unittest for your application without sending emails to non existent email address by mocking the email to be sent. To mock sending out mails, set the suppress configuraton to true. Suppress send defaults to False to prevent mocking within applications.","title":"Writing unittests using Flask-Mailing"},{"location":"#support-for-reply-to-header-is-added","text":"Use this just like bcc but to specify addresses that should receive a reply to your message. E-mail systems MAY respect this as per RFC 2822.","title":"Support for Reply-To header is added"},{"location":"changelog/","text":"0.0.2 \u00b6 Update dependencies 0.0.4 \u00b6 added setup details to pyproject.toml file to solve the dependency error. 0.0.5 \u00b6 Added one more config variable named MAIL_DEFAULT_SENDER . It's as same as MAIL_FROM config var. Fixed absent of httpx module at the setup.py file. Config var MAIL_SSL and MAIL_TLS changes to MAIL_USE_SSL and MAIL_USE_TLS accordingly. added add_recipient and attach method to the schemas.Message class. Fixed some broken test cases. modifications at the documentation. 0.0.6 \u00b6 Now the user can access the Mail object from the app extension dictionary: app.extension['mailing'] 0.0.7 \u00b6 Fixed the long description not found on the PYPI website. 0.1.0 \u00b6 Fixed issue #20 . Now the user can pass template parameters by using template_params variable on the schemas.Message class. Fixed major typo at setup.py Fixed some broken test cases. Fixed the Variable name issue at config.ConnectionConfig class. Fixed Literal import for Python 3.6 and 3.7 Added module docstring. Added future roadmap on the docs. Added some more test cases. Added the compatibility for Python 3.10 Added the feature to allow users to create custom headers for attachments. Updated the MANIFEST.in file. Updated the required dependencies. 0.1.1 \u00b6 Fixed broken test cases for fake redis client. Fixed some typo at utils.email_check file. Added aioredis > 2.0.0 compatibility. Added fully asynchronous support for utils.email_check.EmailChecker class. Updated the utils.email_check.EmailChecker class for the new version of aioredis . Updated the required dependencies. 0.2.0[Upcoming] \u00b6 Added send_mail , send_mass_mail methods very similar to Django or Flask-Mailman . Added more docstring for better understanding of all the apis. Fixed several typos. Fixed major bug at MAIL_START_TLS / MAIL_START_SSL configuration at ConnectionConfig .","title":"Changelog"},{"location":"changelog/#002","text":"Update dependencies","title":"0.0.2"},{"location":"changelog/#004","text":"added setup details to pyproject.toml file to solve the dependency error.","title":"0.0.4"},{"location":"changelog/#005","text":"Added one more config variable named MAIL_DEFAULT_SENDER . It's as same as MAIL_FROM config var. Fixed absent of httpx module at the setup.py file. Config var MAIL_SSL and MAIL_TLS changes to MAIL_USE_SSL and MAIL_USE_TLS accordingly. added add_recipient and attach method to the schemas.Message class. Fixed some broken test cases. modifications at the documentation.","title":"0.0.5"},{"location":"changelog/#006","text":"Now the user can access the Mail object from the app extension dictionary: app.extension['mailing']","title":"0.0.6"},{"location":"changelog/#007","text":"Fixed the long description not found on the PYPI website.","title":"0.0.7"},{"location":"changelog/#010","text":"Fixed issue #20 . Now the user can pass template parameters by using template_params variable on the schemas.Message class. Fixed major typo at setup.py Fixed some broken test cases. Fixed the Variable name issue at config.ConnectionConfig class. Fixed Literal import for Python 3.6 and 3.7 Added module docstring. Added future roadmap on the docs. Added some more test cases. Added the compatibility for Python 3.10 Added the feature to allow users to create custom headers for attachments. Updated the MANIFEST.in file. Updated the required dependencies.","title":"0.1.0"},{"location":"changelog/#011","text":"Fixed broken test cases for fake redis client. Fixed some typo at utils.email_check file. Added aioredis > 2.0.0 compatibility. Added fully asynchronous support for utils.email_check.EmailChecker class. Updated the utils.email_check.EmailChecker class for the new version of aioredis . Updated the required dependencies.","title":"0.1.1"},{"location":"changelog/#020upcoming","text":"Added send_mail , send_mass_mail methods very similar to Django or Flask-Mailman . Added more docstring for better understanding of all the apis. Fixed several typos. Fixed major bug at MAIL_START_TLS / MAIL_START_SSL configuration at ConnectionConfig .","title":"0.2.0[Upcoming]"},{"location":"contribute/","text":"Contributing to flask-mailing \u00b6 We welcome contributions to flask-mailing Issues \u00b6 Feel free to submit issues and enhancement requests. Flask-Mailing Issues Contributing \u00b6 Please refer to each project's style and contribution guidelines for submitting patches and additions. In general, we follow the \"fork-and-pull\" Git workflow. Fork the repo on GitHub Clone the project to your own machine Commit changes to your own branch Push your work Submit a Pull request so that we can review your changes NOTE: Be sure to merge the latest from upstream before making a pull request!","title":"Contribution"},{"location":"contribute/#contributing-to-flask-mailing","text":"We welcome contributions to flask-mailing","title":"Contributing to flask-mailing"},{"location":"contribute/#issues","text":"Feel free to submit issues and enhancement requests. Flask-Mailing Issues","title":"Issues"},{"location":"contribute/#contributing","text":"Please refer to each project's style and contribution guidelines for submitting patches and additions. In general, we follow the \"fork-and-pull\" Git workflow. Fork the repo on GitHub Clone the project to your own machine Commit changes to your own branch Push your work Submit a Pull request so that we can review your changes NOTE: Be sure to merge the latest from upstream before making a pull request!","title":"Contributing"},{"location":"example/","text":"Example \u00b6 Sending emails using Falsk-Email \u00b6 List of Examples \u00b6 Basic configuration \u00b6 from flask import Flask , jsonify from flask_mailing import Mail , Message mail = Mail () def create_app (): app = Flask ( __name__ ) app . config [ 'MAIL_USERNAME' ] = \"your-email@your-domain.com\" app . config [ 'MAIL_PASSWORD' ] = \"world_top_secret_password\" app . config [ 'MAIL_PORT' ] = 587 app . config [ 'MAIL_SERVER' ] = \"your-email-server.com\" app . config [ 'MAIL_USE_TLS' ] = True app . config [ 'MAIL_USE_SSL' ] = False mail . init_app ( app ) return app #send a simple email using flask_mailing module. app = create_app () @app . get ( \"/email\" ) async def simple_send (): message = Message ( subject = \"Flask-Mailing module\" , recipients = [ \"aniketsarkar@yahoo.com\" ], body = \"This is the basic email body\" , ) await mail . send_message ( message ) return jsonify ( status_code = 200 , content = { \"message\" : \"email has been sent\" }) Add recipient using add_recipient method \u00b6 message . add_recipient ( \"recipient@emldomain.com\" ) Send a simple html message \u00b6 html = \"\"\" <p>Hi this test mail, thanks for using Flask-Mailing</p> \"\"\" @app . get ( \"/html-email\" ) async def html_email (): message = Message ( subject = \"Flask-Mailing module test html mail\" , recipients = [ \"aniketsarkar@yahoo.com\" ], body = html , subtype = \"html\" ) await mail . send_message ( message ) return jsonify ( status_code = 200 , content = { \"message\" : \"email has been sent\" }) Sending files \u00b6 @app . get ( \"/mail-file\" ) async def mail_file (): message = Message ( subject = \"attachments based email\" , recipients = [ \"aniketsarkar@yahoo.com\" ], body = \"email with attachments, email body.\" , attachments = [ 'attachments/attachment.txt' ] ) await mail . send_message ( message ) return jsonify ( message = \"email sent\" ) Sending files using attach method \u00b6 with app . open_resource ( \"attachments/example.txt\" ) as fp : message . attach ( \"example.txt\" , fp . read ()) Using Jinja2 HTML Templates \u00b6 You can enable Jinja2 HTML Template emails by setting the TEMPLATE_FOLDER configuration option, and supplying a value (which is just the name of the template file within the TEMPLATE_FOLDER dir) for the template_name parameter in Mail.send_message() . You then can pass a Dict as the template_body property of your Message object. If you haven't provided the TEMPLATE_FOLDER configuration option, then the module will take the app's jinja2 environment for templating and you can use templates from app's default template folder: from pathlib import Path app . config [ \"TEMPLATE_FOLDER\" ] = Path ( __file__ ) . parent / 'email-templates' \"\"\" Don't use this configuration if you want to use the default jinja2 environment. \"\"\" @app . get ( \"/mail-html\" ) async def mail_html (): message = Message ( subject = \"html template based email\" , recipients = [ \"aniketsarkar@yahoo.com\" ], template_body = { \"first_name\" : \"Hare\" , \"last_name\" : \"Krishna\" } # attachments = ['attachments/attachment.txt'] ) #or message = Message ( subject = \"html template based email\" , recipients = [ \"aniketsarkar@yahoo.com\" ], template_params = { \"first_name\" : \"Hare\" , \"last_name\" : \"Krishna\" } # attachments = ['attachments/attachment.txt'] ) await mail . send_message ( message , template_name = \"test.html\" ) return jsonify ( message = \"email sent\" ) For example, assume we pass a template_body of: { \"first_name\" : \"Hare\" , \"last_name\" : \"Krishna\" } We can reference the variables in our Jinja templates as per normal: ... < span > Hello, {{ first_name }}! </ span > ... Legacy Behaviour \u00b6 The original behaviour was to wrap the Dict you provide in a variable named body when it was provided to Jinja behind the scenes. In these versions, you can then access your dict in your template like so: ... <span>Hello, body.first_name !</span> ... As you can see our keys in our dict are no longer the top level, they are part of the body variable. Nesting works as per normal below this level also. Customizing attachments by headers and MIME type \u00b6 Used for example for referencing Content-ID images in html of email message = Message ( subject = 'Flask-Mailing module' , recipients = recipients , html = \"<img src='cid:logo_image'>\" , subtype = 'html' , attachments = [ { \"file\" : \"/path/to/file.png\" ), \"headers\" : { \"Content-ID\" : \"<logo_image>\" }, \"mime_type\" : \"image\" , \"mime_subtype\" : \"png\" , } ], ) fm = FastMail ( conf ) await fm . send_message ( message ) Guide for email utils \u00b6 The utility allows you to check temporary email addresses, you can block any email or domain. You can connect Redis to save and check email addresses. If you do not provide a Redis configuration, then the utility will save it in the list or set by default. Check dispasoble email address \u00b6 async def default_checker (): checker = DefaultChecker () # you can pass source argument for your own email domains await checker . fetch_temp_email_domains () # require to fetch temporary email domains return checker @app . get ( '/email/dispasoble' ) async def simple_send (): domain = \"gmail.com, checker = await default_checker () if await checker . is_dispasoble ( domain ): return jsonify ( status_code = 400 , content = { 'message' : 'this is dispasoble domain' }) return jsonify ( status_code = 200 , content = { 'message' : 'email has been sent' }) Add dispasoble email address \u00b6 @app . get ( '/email/dispasoble' ) async def add_disp_domain (): domains : list = [ \"gmail.com\" ] checker : DefaultChecker = await default_checker () res = await checker . add_temp_domain ( domains ) return jsonify ( status_code = 200 , content = { 'result' : res }) Add domain to blocked list \u00b6 @app . get ( '/email/blocked/domains' ) async def block_domain (): domain : str = \"gmail.com\" checker : DefaultChecker = await default_checker () await checker . blacklist_add_domain ( domain ) return jsonify ( status_code = 200 , content = { 'message' : f ' { domain } added to blacklist' }) Check domain blocked or not \u00b6 @app . get ( '/email/blocked/check-domains' ) async def get_blocked_domain (): domain : str = 'gmail.com' checker : DefaultChecker = await default_checker () res = await checker . is_blocked_domain ( domain ) return jsonify ( status_code = 200 , content = { \"result\" : res }) Add email address to blocked list \u00b6 @app . get ( '/email/blocked/address' ) async def block_address (): email : str = 'hacker@gmail.com' checker : DefaultChecker = await default_checker () await checker . blacklist_add_email ( email ) return jsonify ( status_code = 200 , content = { \"result\" : True }) Check email blocked or not \u00b6 @app . get ( '/email/blocked/address' ) async def get_block_address (): email : str = 'hacker@gmail.com' checker : DefaultChecker = await default_checker () res = await checker . is_blocked_address ( email ) return jsonify ( status_code = 200 , content = { \"result\" : res }) Check MX record \u00b6 @app . get ( \"/email/check-mx\" ) async def check_mx_record (): checker = await default_checker () domain = \"gmail.com\" res = await checker . check_mx_record ( domain , False ) return jsonify ( status_code = 200 , content = { 'result' : res }) Remove email address from blocked list \u00b6 @app . get ( '/email/blocked/address' ) async def del_blocked_address (): checker = await default_checker () email = \"hacker@gmail.com\" res = await checker . blacklist_rm_email ( email ) return jsonify ( status_code = 200 , content = { \"result\" : res }) Remove domain from blocked list \u00b6 @app . get ( '/email/blocked/domains' ) async def del_blocked_domain (): checker = await default_checker () domain = \"gmail.com\" res = await checker . blacklist_rm_domain ( domain ) return jsonify ( status_code = 200 , content = { \"result\" : res }) Remove domain from temporary list \u00b6 @app . get ( '/email/dispasoblee' ) async def del_disp_domain (): checker = await default_checker () domains = [ \"gmail.com\" ] res = await checker . blacklist_rm_temp ( domains ) return jsonify ( status_code = 200 , content = { 'result' : res }) WhoIsXmlApi \u00b6 from flask_mailing.utils import WhoIsXmlApi who_is = WhoIsXmlApi ( token = \"Your access token\" , email = \"your@mailaddress.com\" ) print ( who_is . smtp_check_ ()) #check smtp server print ( who_is . is_dispasoble ()) # check email is disposable or not print ( who_is . check_mx_record ()) # check domain mx records print ( who_is . free_check ) # check email domain is free or not","title":"Example"},{"location":"example/#example","text":"","title":"Example"},{"location":"example/#sending-emails-using-falsk-email","text":"","title":"Sending emails using Falsk-Email"},{"location":"example/#list-of-examples","text":"","title":"List of Examples"},{"location":"example/#basic-configuration","text":"from flask import Flask , jsonify from flask_mailing import Mail , Message mail = Mail () def create_app (): app = Flask ( __name__ ) app . config [ 'MAIL_USERNAME' ] = \"your-email@your-domain.com\" app . config [ 'MAIL_PASSWORD' ] = \"world_top_secret_password\" app . config [ 'MAIL_PORT' ] = 587 app . config [ 'MAIL_SERVER' ] = \"your-email-server.com\" app . config [ 'MAIL_USE_TLS' ] = True app . config [ 'MAIL_USE_SSL' ] = False mail . init_app ( app ) return app #send a simple email using flask_mailing module. app = create_app () @app . get ( \"/email\" ) async def simple_send (): message = Message ( subject = \"Flask-Mailing module\" , recipients = [ \"aniketsarkar@yahoo.com\" ], body = \"This is the basic email body\" , ) await mail . send_message ( message ) return jsonify ( status_code = 200 , content = { \"message\" : \"email has been sent\" })","title":"Basic configuration"},{"location":"example/#add-recipient-using-add_recipient-method","text":"message . add_recipient ( \"recipient@emldomain.com\" )","title":"Add recipient using add_recipient method"},{"location":"example/#send-a-simple-html-message","text":"html = \"\"\" <p>Hi this test mail, thanks for using Flask-Mailing</p> \"\"\" @app . get ( \"/html-email\" ) async def html_email (): message = Message ( subject = \"Flask-Mailing module test html mail\" , recipients = [ \"aniketsarkar@yahoo.com\" ], body = html , subtype = \"html\" ) await mail . send_message ( message ) return jsonify ( status_code = 200 , content = { \"message\" : \"email has been sent\" })","title":"Send a simple html message"},{"location":"example/#sending-files","text":"@app . get ( \"/mail-file\" ) async def mail_file (): message = Message ( subject = \"attachments based email\" , recipients = [ \"aniketsarkar@yahoo.com\" ], body = \"email with attachments, email body.\" , attachments = [ 'attachments/attachment.txt' ] ) await mail . send_message ( message ) return jsonify ( message = \"email sent\" )","title":"Sending files"},{"location":"example/#sending-files-using-attach-method","text":"with app . open_resource ( \"attachments/example.txt\" ) as fp : message . attach ( \"example.txt\" , fp . read ())","title":"Sending files using attach method"},{"location":"example/#using-jinja2-html-templates","text":"You can enable Jinja2 HTML Template emails by setting the TEMPLATE_FOLDER configuration option, and supplying a value (which is just the name of the template file within the TEMPLATE_FOLDER dir) for the template_name parameter in Mail.send_message() . You then can pass a Dict as the template_body property of your Message object. If you haven't provided the TEMPLATE_FOLDER configuration option, then the module will take the app's jinja2 environment for templating and you can use templates from app's default template folder: from pathlib import Path app . config [ \"TEMPLATE_FOLDER\" ] = Path ( __file__ ) . parent / 'email-templates' \"\"\" Don't use this configuration if you want to use the default jinja2 environment. \"\"\" @app . get ( \"/mail-html\" ) async def mail_html (): message = Message ( subject = \"html template based email\" , recipients = [ \"aniketsarkar@yahoo.com\" ], template_body = { \"first_name\" : \"Hare\" , \"last_name\" : \"Krishna\" } # attachments = ['attachments/attachment.txt'] ) #or message = Message ( subject = \"html template based email\" , recipients = [ \"aniketsarkar@yahoo.com\" ], template_params = { \"first_name\" : \"Hare\" , \"last_name\" : \"Krishna\" } # attachments = ['attachments/attachment.txt'] ) await mail . send_message ( message , template_name = \"test.html\" ) return jsonify ( message = \"email sent\" ) For example, assume we pass a template_body of: { \"first_name\" : \"Hare\" , \"last_name\" : \"Krishna\" } We can reference the variables in our Jinja templates as per normal: ... < span > Hello, {{ first_name }}! </ span > ...","title":"Using Jinja2 HTML Templates"},{"location":"example/#legacy-behaviour","text":"The original behaviour was to wrap the Dict you provide in a variable named body when it was provided to Jinja behind the scenes. In these versions, you can then access your dict in your template like so: ... <span>Hello, body.first_name !</span> ... As you can see our keys in our dict are no longer the top level, they are part of the body variable. Nesting works as per normal below this level also.","title":"Legacy Behaviour"},{"location":"example/#customizing-attachments-by-headers-and-mime-type","text":"Used for example for referencing Content-ID images in html of email message = Message ( subject = 'Flask-Mailing module' , recipients = recipients , html = \"<img src='cid:logo_image'>\" , subtype = 'html' , attachments = [ { \"file\" : \"/path/to/file.png\" ), \"headers\" : { \"Content-ID\" : \"<logo_image>\" }, \"mime_type\" : \"image\" , \"mime_subtype\" : \"png\" , } ], ) fm = FastMail ( conf ) await fm . send_message ( message )","title":"Customizing attachments by headers and MIME type"},{"location":"example/#guide-for-email-utils","text":"The utility allows you to check temporary email addresses, you can block any email or domain. You can connect Redis to save and check email addresses. If you do not provide a Redis configuration, then the utility will save it in the list or set by default.","title":"Guide for email utils"},{"location":"example/#check-dispasoble-email-address","text":"async def default_checker (): checker = DefaultChecker () # you can pass source argument for your own email domains await checker . fetch_temp_email_domains () # require to fetch temporary email domains return checker @app . get ( '/email/dispasoble' ) async def simple_send (): domain = \"gmail.com, checker = await default_checker () if await checker . is_dispasoble ( domain ): return jsonify ( status_code = 400 , content = { 'message' : 'this is dispasoble domain' }) return jsonify ( status_code = 200 , content = { 'message' : 'email has been sent' })","title":"Check dispasoble email address"},{"location":"example/#add-dispasoble-email-address","text":"@app . get ( '/email/dispasoble' ) async def add_disp_domain (): domains : list = [ \"gmail.com\" ] checker : DefaultChecker = await default_checker () res = await checker . add_temp_domain ( domains ) return jsonify ( status_code = 200 , content = { 'result' : res })","title":"Add dispasoble email address"},{"location":"example/#add-domain-to-blocked-list","text":"@app . get ( '/email/blocked/domains' ) async def block_domain (): domain : str = \"gmail.com\" checker : DefaultChecker = await default_checker () await checker . blacklist_add_domain ( domain ) return jsonify ( status_code = 200 , content = { 'message' : f ' { domain } added to blacklist' })","title":"Add domain to blocked list"},{"location":"example/#check-domain-blocked-or-not","text":"@app . get ( '/email/blocked/check-domains' ) async def get_blocked_domain (): domain : str = 'gmail.com' checker : DefaultChecker = await default_checker () res = await checker . is_blocked_domain ( domain ) return jsonify ( status_code = 200 , content = { \"result\" : res })","title":"Check domain blocked or not"},{"location":"example/#add-email-address-to-blocked-list","text":"@app . get ( '/email/blocked/address' ) async def block_address (): email : str = 'hacker@gmail.com' checker : DefaultChecker = await default_checker () await checker . blacklist_add_email ( email ) return jsonify ( status_code = 200 , content = { \"result\" : True })","title":"Add email address to blocked list"},{"location":"example/#check-email-blocked-or-not","text":"@app . get ( '/email/blocked/address' ) async def get_block_address (): email : str = 'hacker@gmail.com' checker : DefaultChecker = await default_checker () res = await checker . is_blocked_address ( email ) return jsonify ( status_code = 200 , content = { \"result\" : res })","title":"Check email blocked or not"},{"location":"example/#check-mx-record","text":"@app . get ( \"/email/check-mx\" ) async def check_mx_record (): checker = await default_checker () domain = \"gmail.com\" res = await checker . check_mx_record ( domain , False ) return jsonify ( status_code = 200 , content = { 'result' : res })","title":"Check MX record"},{"location":"example/#remove-email-address-from-blocked-list","text":"@app . get ( '/email/blocked/address' ) async def del_blocked_address (): checker = await default_checker () email = \"hacker@gmail.com\" res = await checker . blacklist_rm_email ( email ) return jsonify ( status_code = 200 , content = { \"result\" : res })","title":"Remove email address from blocked list"},{"location":"example/#remove-domain-from-blocked-list","text":"@app . get ( '/email/blocked/domains' ) async def del_blocked_domain (): checker = await default_checker () domain = \"gmail.com\" res = await checker . blacklist_rm_domain ( domain ) return jsonify ( status_code = 200 , content = { \"result\" : res })","title":"Remove domain from blocked list"},{"location":"example/#remove-domain-from-temporary-list","text":"@app . get ( '/email/dispasoblee' ) async def del_disp_domain (): checker = await default_checker () domains = [ \"gmail.com\" ] res = await checker . blacklist_rm_temp ( domains ) return jsonify ( status_code = 200 , content = { 'result' : res })","title":"Remove domain from temporary list"},{"location":"example/#whoisxmlapi","text":"from flask_mailing.utils import WhoIsXmlApi who_is = WhoIsXmlApi ( token = \"Your access token\" , email = \"your@mailaddress.com\" ) print ( who_is . smtp_check_ ()) #check smtp server print ( who_is . is_dispasoble ()) # check email is disposable or not print ( who_is . check_mx_record ()) # check domain mx records print ( who_is . free_check ) # check email domain is free or not","title":"WhoIsXmlApi"},{"location":"future-roadmap/","text":"Future Roadmap \u00b6 Flask-Mailing will start supporting synchronous methods.","title":"Future Roadmap"},{"location":"future-roadmap/#future-roadmap","text":"Flask-Mailing will start supporting synchronous methods.","title":"Future Roadmap"},{"location":"getting-started/","text":"\ud83d\udd79 Guide \u00b6 After installing the module and setting up your Flask app: Main classes and packages are Mail Message utils.DefaultChecker utils.WhoIsXmlApi Available config options \u00b6 class has following attributes MAIL_USERNAME : Username for email, some email hosts separates username from the default sender(AWS). If you service does not provide username use sender address for connection. MAIL_PASSWORD : Password for authentication MAIL_SERVER : SMTP Mail server. MAIL_USE_TLS : For TLS connection MAIL_USE_SSL : For TLS connection MAIL_DEBUG : Debug mode for while sending mails, defaults 0. MAIL_FROM : Sender address MAIL_DEFAULT_SENDER : Sender address MAIL_FROM_NAME : Title for Mail TEMPLATE_FOLDER : If you are using jinja2, specify template folder name SUPPRESS_SEND : To mock sending out mail, defaults 0. USE_CREDENTIALS : Defaults to True . However it enables users to choose whether or not to login to their SMTP server. VALIDATE_CERTS : Defaults to True . It enables to choose whether to verify the mail server's certificate Mail class \u00b6 class has following attributes and methods send_message : The methods has two atributes, message: Message, template_name=None message : where you define message sturcture for email template_name : if you are using jinja2 consider template_name as well for passing HTML. send_mail : sending emails with message string and recipients very similar to Django. subject : A String containing the subject of the message. message : A string containing the message body. recipients : A list of strings, each an email address. Each member of recipients will see the other recipients in the \u201cTo:\u201d field of the email message. msgkwargs : the kwargs based parameters for Message class. send_mass_mail : To handle mass mailing. datatuple : is a tuple in which each element is in this format: ( subject, message, recipients ) Message class \u00b6 class has following attributes recipients : List of recipients. attachments : attachments within mail subject : subject content of the mail body : body of the message cc : cc recipients of the mail bcc : bcc recipients of the mail reply_to : Reply-To recipients in the mail charset : charset defaults to utf-8 subtype : subtype of the mail defaults to plain add_recipient : a method to add additional recipients. attach : a method to add additional attachments. utils.DefaultChecker class \u00b6 Default class for checking email from collected public resource. The class makes it possible to use redis to save data. source : optional source for collected email data. db_provider : switch to redis utils.WhoIsXmlApi class \u00b6 WhoIsXmlApi class provide working with api WhoIsXmlApi This service gives free 1000 request to checking email address per month. token : token you can get from this WhoIsXmlApi link email : email for checking","title":"\ud83d\udd79 Getting Started"},{"location":"getting-started/#guide","text":"After installing the module and setting up your Flask app: Main classes and packages are Mail Message utils.DefaultChecker utils.WhoIsXmlApi","title":"\ud83d\udd79 Guide"},{"location":"getting-started/#available-config-options","text":"class has following attributes MAIL_USERNAME : Username for email, some email hosts separates username from the default sender(AWS). If you service does not provide username use sender address for connection. MAIL_PASSWORD : Password for authentication MAIL_SERVER : SMTP Mail server. MAIL_USE_TLS : For TLS connection MAIL_USE_SSL : For TLS connection MAIL_DEBUG : Debug mode for while sending mails, defaults 0. MAIL_FROM : Sender address MAIL_DEFAULT_SENDER : Sender address MAIL_FROM_NAME : Title for Mail TEMPLATE_FOLDER : If you are using jinja2, specify template folder name SUPPRESS_SEND : To mock sending out mail, defaults 0. USE_CREDENTIALS : Defaults to True . However it enables users to choose whether or not to login to their SMTP server. VALIDATE_CERTS : Defaults to True . It enables to choose whether to verify the mail server's certificate","title":"Available config options"},{"location":"getting-started/#mail-class","text":"class has following attributes and methods send_message : The methods has two atributes, message: Message, template_name=None message : where you define message sturcture for email template_name : if you are using jinja2 consider template_name as well for passing HTML. send_mail : sending emails with message string and recipients very similar to Django. subject : A String containing the subject of the message. message : A string containing the message body. recipients : A list of strings, each an email address. Each member of recipients will see the other recipients in the \u201cTo:\u201d field of the email message. msgkwargs : the kwargs based parameters for Message class. send_mass_mail : To handle mass mailing. datatuple : is a tuple in which each element is in this format: ( subject, message, recipients )","title":"Mail class"},{"location":"getting-started/#message-class","text":"class has following attributes recipients : List of recipients. attachments : attachments within mail subject : subject content of the mail body : body of the message cc : cc recipients of the mail bcc : bcc recipients of the mail reply_to : Reply-To recipients in the mail charset : charset defaults to utf-8 subtype : subtype of the mail defaults to plain add_recipient : a method to add additional recipients. attach : a method to add additional attachments.","title":"Message class"},{"location":"getting-started/#utilsdefaultchecker-class","text":"Default class for checking email from collected public resource. The class makes it possible to use redis to save data. source : optional source for collected email data. db_provider : switch to redis","title":"utils.DefaultChecker class"},{"location":"getting-started/#utilswhoisxmlapi-class","text":"WhoIsXmlApi class provide working with api WhoIsXmlApi This service gives free 1000 request to checking email address per month. token : token you can get from this WhoIsXmlApi link email : email for checking","title":"utils.WhoIsXmlApi class"},{"location":"install/","text":"Using pip \u00b6 python3 -m venv .venv source .venv/bin/activate pip install flask-mailing Using source code \u00b6 git clone https://github.com/marktennyson/flask-mailing && cd flask-mailing python3 setup.py install","title":"\ud83d\udd28 Installation"},{"location":"install/#using-pip","text":"python3 -m venv .venv source .venv/bin/activate pip install flask-mailing","title":"Using pip"},{"location":"install/#using-source-code","text":"git clone https://github.com/marktennyson/flask-mailing && cd flask-mailing python3 setup.py install","title":"Using source code"}]}